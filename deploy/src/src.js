import * as d3 from 'd3';
import * as tf from '@tensorflow/tfjs';

// Globally available and useful variables.
let objects, predicates, annotations, model;
let nodes_data, links_data;
let image_canvas, image_height, image_width;
let graph_canvas, graph_simulation, graph_nodes, graph_links;
// TODO Change these to be read from html/css
const [graph_width, graph_height] = [350, 350];
const margin = 10;

// Some of these would be generated by the model.
const promises = [
    d3.json('./objects.json'),
    d3.json('./predicates.json'),
    d3.json('./annotations.json'),
    //tf.loadModel('./vgg16/model.json'/*'./densenet121/model.json'*/),
];

// Wait for all data/model promises to resolve and call the allLoaded function.
Promise.all(promises)
    .then(allLoaded)
    .catch(error => console.log(error));

// The "main" function.
function allLoaded(promises) {
    [objects, predicates, annotations/*, model*/] = promises;
    processData();
    createCanvases();
    drawBoxes();
    drawConnections();
}

// Turn the annotations into 
function processData() {
    nodes_data = [];
    links_data = annotations.map(annotation => ({
        source: addNodeAndReturnIndex(annotation.object),
        target: addNodeAndReturnIndex(annotation.subject),
        label: predicates[annotation.predicate],
    }));
}

function addNodeAndReturnIndex(subject_object) {
    // Turn the BBox into strings to use as keys to avoid duplicate object nodes.
    // This should not be needed when annoations are generated.
    const bbox_key = subject_object.bbox.join('<~>');
    let node_index = nodes_data.findIndex(node => node.bbox.join('<~>') == bbox_key);
    if (node_index === -1) {
        node_index = nodes_data.length;
        nodes_data.push({
            label: objects[subject_object.category],
            // Attributes added here.
            ...makeBBoxNice(subject_object.bbox),
        })
    }
    return node_index;
}

function makeBBoxNice(bbox) {
    return {
        bbox: bbox,
        left: bbox[2],
        right: bbox[3],
        up: bbox[0],
        down: bbox[1],
        up_left: {x: bbox[2], y: bbox[0]},
        up_right: {x: bbox[3], y: bbox[0]},
        down_left: {x: bbox[2], y: bbox[1]},
        down_right: {x: bbox[3], y: bbox[1]},
    };
}

// Creates an real encompassing svg canvas and two groups that act as their own canvases.
// Do all the ugly double canvas with margins math here to not do it elsewhere.
function createCanvases() {
    const img_container = d3.select('#image-container');
    const img = img_container.select('img').node();
    [image_height, image_width] = [img.naturalHeight, img.naturalWidth];
    // Create a real svg canvas that is large enough for the image + graph + margins/
    const canvas = img_container.append('svg')
        .attr('transform', `translate(${-margin}, ${-margin})`)
        .attr('height', margin * 2 + image_height + graph_height)
        .attr('width', margin * 3 + image_width + graph_width)
    // Create the two fake canvases.
    image_canvas = canvas.append('g')
        .attr('transform', `translate(${margin}, ${margin})`);
    graph_canvas = canvas.append('g')
        .attr('transform', `translate(${margin * 2 + image_width}, ${margin})`);
}

function drawBoxes() {
    image_canvas.selectAll('rect')
        .data(nodes_data)
        .enter().append('rect')
            .attr('class', 'bbox')
            .attr('x', d => d.left)
            .attr('y', d => d.up)
            .attr('width', d => d.right - d.left)
            .attr('height', d => d.down - d.up);
}

function drawConnections() {
    image_canvas.selectAll('line')
        .data(links_data)
        .enter().append('line').each((d, i, nodes) => {
            const [object_corner, subject_corner] = closestPointPair(
                nodes_data[d.source],
                nodes_data[d.target],
                true,
            );
            // Arrow functions don't play nice with selection.each().
            d3.select(nodes[i])
                .attr('class', 'connection')
                .attr('x1', object_corner.x)
                .attr('y1', object_corner.y)
                .attr('x2', subject_corner.x)
                .attr('y2', subject_corner.y);
        });
}

function closestPointPair(lhs_node, rhs_node, offset_radius) {
    // Calculate smallest distance between each bbox's four corners.
    const corner_keys = ['up_left', 'up_right', 'down_left', 'down_right'];
    let min_distance = Infinity;
    let min_lhs_key, min_rhs_key;
    for (const lhs_key of corner_keys) {
        for (const rhs_key of corner_keys) {
            const distance = euclidianDistance(lhs_node[lhs_key], rhs_node[rhs_key]);
            if (distance <= min_distance) {
                [min_distance, min_lhs_key, min_rhs_key] = [distance, lhs_key, rhs_key];
            }
        }
    }
    // Split the keys into axes to apply the direction's respective radius offsets.
    const [lhs_y, lhs_x] = min_lhs_key.split('_');
    const [rhs_y, rhs_x] = min_rhs_key.split('_');
    let radius = 0;
    if (offset_radius) {
        // Grab the radius offset from the css sheet.
        const style = document.styleSheets[0].cssRules[0].style;
        radius = parseFloat(style.getPropertyValue('--radius')) / 2;
    }
    const offsets = {left: radius, right: -radius, up: radius, down: -radius};
    // Return two point objects.
    return [
        {
            x: lhs_node[lhs_x] + offsets[lhs_x],
            y: lhs_node[lhs_y] + offsets[lhs_y],
        }, {
            x: rhs_node[rhs_x] + offsets[rhs_x],
            y: rhs_node[rhs_y] + offsets[rhs_y],
        },
    ];
}

function euclidianDistance(point_a, point_b) {
    const x_squared = Math.pow(point_a.x - point_b.x, 2);
    const y_squared = Math.pow(point_a.y - point_b.y, 2);
    return Math.sqrt(x_squared + y_squared);
}

function createSimulation() {
    nodes = d3.map()
    for (const annotation of annotations) {
        nodes.set(annotation.object.bbox.join('-'), annotation.object.label);
        nodes.set(annotation.subject.bbox.join('-'), annotation.subject.label);
    }
    nodes = nodes.entries().map(x => ({id: x.key, label: x.value}))
    links = annotations.map(annotation => ({
        source: annotation.object.bbox.join('-'),
        target: annotation.subject.bbox.join('-'),
        label: annotation.label,
    }))

    simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink().distance(40).id(d => d.id))
        .force('charge', d3.forceManyBody().distanceMax(125).strength(-50))
        .force('center', d3.forceCenter(simulation_width / 2, simulation_height / 2))
        .on('tick', tickSimulation);

    simulation.force('link').links(links);

    links = simulation_canvas.selectAll('line')
        .data(links)
        .enter().append('line')
            .attr('class', 'link')

    nodes = simulation_canvas.selectAll('circle')
        .data(nodes)
        .enter().append('circle')
            .attr('class', 'node')
}

function tickSimulation() {
    links
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
    nodes
        .attr('cx', d => d.x)
        .attr('cy', d => d.y);
}
